// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id Int @id @default(autoincrement())
  phoneNumber String @unique
  username String?  @unique
  photoProfil String?
  birthday DateTime?
  horoscope String?
  hobbies Json?
  langage Json?
  description String?
  preference Json?
  genre Genre?
  coins Int  @default(0)
  isCertified Boolean  @default(false)
  isCompleted Boolean @default(false)
  isFake Boolean  @default(false)
  longitude Decimal?
  latitude Decimal?
  pays String?
  villes String?
  isOnline Boolean  @default(false)
  preferencePays String?
  disponiblePour String?
  isVideoEnabled Boolean @default(false)
  isLockEnabled Boolean @default(false)
  firstOtherPhoto String?
  secondOtherPhoto String?
  thirdOtherPhoto String?
  role Role @default(USER)
  assignedAgent Int?
  deviceToken String?
  to Match[] @relation("to")
  from   Match[] @relation("from")
  toNotified Notification[] @relation("toNotified") 
  fromNotified   Notification[] @relation("fromNotified")
  socketMapping SocketMapping?
  initiatedLock LockedConversation[] @relation("initiatedLocks")
  receivedLock LockedConversation[] @relation("receivedLocks")
  podiumUsers Podium[]
  restoLikes LikedResto[]
  hostelLikes LikedHostel[]
  restoReservations RestoReservation[]
  hostelReservations HostelReservation[]
}

enum Genre {
  male
  female
  neutre
}

enum Role {
  USER
  ADMIN
  AGENT
}

model Match {
  id     Int    @id @default(autoincrement())
  from    User @relation("from", fields: [fromId], references: [id])
  fromId  Int
  to   User @relation("to", fields: [toId], references: [id])
  toId Int
  isConfirm Boolean @default(false)
  typeMatch TypeMatch  @default(normal)
}

enum TypeMatch {
  boost
  normal
}

model Notification {
  id     Int    @id @default(autoincrement())
  title  String 
  content String
  from    User @relation("fromNotified", fields: [fromNotifiedId], references: [id])
  fromNotifiedId  Int
  to   User @relation("toNotified", fields: [toNotifiedId], references: [id])
  toNotifiedId Int
}

model ChatRoom {
  id     Int    @id @default(autoincrement())
  participant Json
  lastMessage String?  @db.VarChar(1000)
  lastMessageSender Int?
  lastMessageStatus LastMessageStatus @default(pending)
  isSentByAgent Boolean  @default(false)
  agentId Int?
  messages     Message[]
}


enum LastMessageStatus {
  pending
  send
  unsend
  received
  read
}

model Message {
  id          Int       @id @default(autoincrement())
  contenu     String    @db.VarChar(1000)
  title       String?
  mediaUrl    String?
  typeMessage TypeMessage @default(text)
  sender      Int
  dateMessage DateTime
  status      Status    @default(pending)
  isSentByAgent Boolean  @default(false)
// gift       Gift      @relation(fields: [giftId], references: [id])
// giftId     Int       @unique
  chatRoom    ChatRoom  @relation(fields: [chatId], references: [id])
  chatId      Int
}

enum TypeMessage {
  image
  gift
  text
  custom
}

enum Status {
  pending
  send
  unsend
  received
  read
}

model Gift {
  id     Int    @id @default(autoincrement())
  nom String
  prix Decimal
  image String
  giftCategory  GiftCategory  @default(unclassified)
  isAvailable Boolean @default(true)
//  message        Message?
}

enum GiftCategory {
  rose
  mode_beaute
  fitness_bien_etre
  cuisine_gastronomie
  bijoux_accessoires
  art_creativite
  musique
  technologie_gadget
  litterature_ecriture
  jardinage
  jeux_loisirs
  sextoys
  unclassified
}

model SocketMapping {
  id         Int           @id @default(autoincrement())
  socketId   String        @unique
  user       User          @relation(fields: [userId], references: [id])
  userId     Int           @unique
}

model LockedConversation {
  id         Int       @id @default(autoincrement())
  initiator  User      @relation("initiatedLocks", fields: [initiatorId], references: [id])
  initiatorId Int      
  receiver   User      @relation("receivedLocks", fields: [receiverId], references: [id])
  receiverId Int

  @@unique([initiatorId, receiverId])
}

enum PodiumStatus {
  NONE
  COUNTRY
  WORLD
}

model Podium {
  id         Int              @id @default(autoincrement())
  userId     Int              @unique
  status     PodiumStatus     @default(NONE)
  createdAt  DateTime         @default(now())

  user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Country {
  id         Int              @id @default(autoincrement())
  name       String           @unique
  sigle      String           @unique 
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  restos Resto[]
  hostels Hostel[]
}

model City {
  id         Int              @id @default(autoincrement())
  name       String           @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  restos Resto[]
  hostels Hostel[]
}

model Resto {
  id              Int              @id @default(autoincrement())
  name            String
  description     String?
  location        String?
  OpenDaysTime    Json
  countryId       Int
  cityId          Int
  image           String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  country         Country             @relation(fields: [countryId], references: [id])
  city            City                @relation(fields: [cityId], references: [id])
  likes           LikedResto[]
  reservations    RestoReservation[]
}

model Hostel {
  id              Int              @id @default(autoincrement())
  name            String
  description     String?
  location        String?
  countryId       Int
  cityId          Int
  image           String
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  country         Country          @relation(fields: [countryId], references: [id])
  city            City             @relation(fields: [cityId], references: [id])
  likes           LikedHostel[]
  reservations    HostelReservation[]
}

model LikedResto {
  id              Int              @id @default(autoincrement())
  userId          Int              
  restoId         Int              
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  resto           Resto            @relation(fields: [restoId], references: [id], onDelete: Cascade)
}

model LikedHostel {
  id              Int              @id @default(autoincrement())
  userId          Int              
  hostelId        Int              
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  hostel          Hostel           @relation(fields: [hostelId], references: [id], onDelete: Cascade)
}

model RestoReservation {
  id              Int              @id @default(autoincrement())
  userId          Int
  restoId         Int   
  startDate       DateTime
  endDate         DateTime
  totalPrice      Int?
  createdAt       DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  resto           Resto   @relation(fields: [restoId], references: [id], onDelete: Cascade)
}

model HostelReservation {
  id              Int              @id @default(autoincrement())
  userId          Int
  hostelId        Int   
  startDate       DateTime
  endDate         DateTime
  totalPrice      Int?
  createdAt       DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  hostel          Hostel   @relation(fields: [hostelId], references: [id], onDelete: Cascade)
}
